<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Predictability - Rust API Guidelines</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="about.html">About</a></li><li class="affix"><a href="checklist.html">Checklist</a></li><li><a href="naming.html"><strong>1.</strong> Naming</a></li><li><a href="interoperability.html"><strong>2.</strong> Interoperability</a></li><li><a href="macros.html"><strong>3.</strong> Macros</a></li><li><a href="documentation.html"><strong>4.</strong> Documentation</a></li><li><a href="predictability.html" class="active"><strong>5.</strong> Predictability</a></li><li><a href="flexibility.html"><strong>6.</strong> Flexibility</a></li><li><a href="type-safety.html"><strong>7.</strong> Type safety</a></li><li><a href="dependability.html"><strong>8.</strong> Dependability</a></li><li><a href="debuggability.html"><strong>9.</strong> Debuggability</a></li><li><a href="future-proofing.html"><strong>10.</strong> Future proofing</a></li><li><a href="necessities.html"><strong>11.</strong> Necessities</a></li><li class="affix"><a href="external-links.html">External links</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">Rust API Guidelines</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="predictability.html#predictability" id="predictability"><h1>Predictability</h1></a>
<p><a id="c-smart-ptr"></a></p>
<a class="header" href="predictability.html#smart-pointers-do-not-add-inherent-methods-c-smart-ptr" id="smart-pointers-do-not-add-inherent-methods-c-smart-ptr"><h2>Smart pointers do not add inherent methods (C-SMART-PTR)</h2></a>
<p>For example, this is why the <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.into_raw"><code>Box::into_raw</code></a> function is defined the way it
is.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;T&gt; Box&lt;T&gt; where T: ?Sized {
    fn into_raw(b: Box&lt;T&gt;) -&gt; *mut T { /* ... */ }
}

let boxed_str: Box&lt;str&gt; = /* ... */;
let ptr = Box::into_raw(boxed_str);
#}</code></pre></pre>
<p>If this were defined as an inherent method instead, it would be confusing at the
call site whether the method being called is a method on <code>Box&lt;T&gt;</code> or a method on
<code>T</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;T&gt; Box&lt;T&gt; where T: ?Sized {
    // Do not do this.
    fn into_raw(self) -&gt; *mut T { /* ... */ }
}

let boxed_str: Box&lt;str&gt; = /* ... */;

// This is a method on str accessed through the smart pointer Deref impl.
boxed_str.chars()

// This is a method on Box&lt;str&gt;...?
boxed_str.into_raw()
#}</code></pre></pre>
<p><a id="c-conv-specific"></a></p>
<a class="header" href="predictability.html#conversions-live-on-the-most-specific-type-involved-c-conv-specific" id="conversions-live-on-the-most-specific-type-involved-c-conv-specific"><h2>Conversions live on the most specific type involved (C-CONV-SPECIFIC)</h2></a>
<p>When in doubt, prefer <code>to_</code>/<code>as_</code>/<code>into_</code> to <code>from_</code>, because they are more
ergonomic to use (and can be chained with other methods).</p>
<p>For many conversions between two types, one of the types is clearly more
&quot;specific&quot;: it provides some additional invariant or interpretation that is not
present in the other type. For example, <a href="https://doc.rust-lang.org/std/primitive.str.html"><code>str</code></a> is more specific than <code>&amp;[u8]</code>,
since it is a UTF-8 encoded sequence of bytes.</p>
<p>Conversions should live with the more specific of the involved types. Thus,
<code>str</code> provides both the <a href="https://doc.rust-lang.org/std/primitive.str.html#method.as_bytes"><code>as_bytes</code></a> method and the <a href="https://doc.rust-lang.org/std/str/fn.from_utf8.html"><code>from_utf8</code></a> constructor
for converting to and from <code>&amp;[u8]</code> values. Besides being intuitive, this
convention avoids polluting concrete types like <code>&amp;[u8]</code> with endless conversion
methods.</p>
<p><a id="c-method"></a></p>
<a class="header" href="predictability.html#functions-with-a-clear-receiver-are-methods-c-method" id="functions-with-a-clear-receiver-are-methods-c-method"><h2>Functions with a clear receiver are methods (C-METHOD)</h2></a>
<p>Prefer</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Foo {
    pub fn frob(&amp;self, w: widget) { /* ... */ }
}
#}</code></pre></pre>
<p>over</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn frob(foo: &amp;Foo, w: widget) { /* ... */ }
#}</code></pre></pre>
<p>for any operation that is clearly associated with a particular type.</p>
<p>Methods have numerous advantages over functions:</p>
<ul>
<li>They do not need to be imported or qualified to be used: all you need is a
value of the appropriate type.</li>
<li>Their invocation performs autoborrowing (including mutable borrows).</li>
<li>They make it easy to answer the question &quot;what can I do with a value of type
<code>T</code>&quot; (especially when using rustdoc).</li>
<li>They provide <code>self</code> notation, which is more concise and often more clearly
conveys ownership distinctions.</li>
</ul>
<p><a id="c-no-out"></a></p>
<a class="header" href="predictability.html#functions-do-not-take-out-parameters-c-no-out" id="functions-do-not-take-out-parameters-c-no-out"><h2>Functions do not take out-parameters (C-NO-OUT)</h2></a>
<p>Prefer</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo() -&gt; (Bar, Bar)
#}</code></pre></pre>
<p>over</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(output: &amp;mut Bar) -&gt; Bar
#}</code></pre></pre>
<p>for returning multiple <code>Bar</code> values.</p>
<p>Compound return types like tuples and structs are efficiently compiled and do
not require heap allocation. If a function needs to return multiple values, it
should do so via one of these types.</p>
<p>The primary exception: sometimes a function is meant to modify data that the
caller already owns, for example to re-use a buffer:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;usize&gt;
#}</code></pre></pre>
<p><a id="c-overload"></a></p>
<a class="header" href="predictability.html#operator-overloads-are-unsurprising-c-overload" id="operator-overloads-are-unsurprising-c-overload"><h2>Operator overloads are unsurprising (C-OVERLOAD)</h2></a>
<p>Operators with built in syntax (<code>*</code>, <code>|</code>, and so on) can be provided for a type
by implementing the traits in <a href="https://doc.rust-lang.org/std/ops/index.html#traits"><code>std::ops</code></a>. These operators come with strong
expectations: implement <code>Mul</code> only for an operation that bears some resemblance
to multiplication (and shares the expected properties, e.g. associativity), and
so on for the other traits.</p>
<p><a id="c-deref"></a></p>
<a class="header" href="predictability.html#only-smart-pointers-implement-deref-and-derefmut-c-deref" id="only-smart-pointers-implement-deref-and-derefmut-c-deref"><h2>Only smart pointers implement <code>Deref</code> and <code>DerefMut</code> (C-DEREF)</h2></a>
<p>The <code>Deref</code> traits are used implicitly by the compiler in many circumstances,
and interact with method resolution. The relevant rules are designed
specifically to accommodate smart pointers, and so the traits should be used
only for that purpose.</p>
<a class="header" href="predictability.html#examples-from-the-standard-library" id="examples-from-the-standard-library"><h3>Examples from the standard library</h3></a>
<ul>
<li><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a></li>
<li><a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> is a smart
pointer to <a href="https://doc.rust-lang.org/std/primitive.str.html"><code>str</code></a></li>
<li><a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc&lt;T&gt;</code></a></li>
<li><a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a></li>
<li><a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>Cow&lt;'a, T&gt;</code></a></li>
</ul>
<p><a id="c-ctor"></a></p>
<a class="header" href="predictability.html#constructors-are-static-inherent-methods-c-ctor" id="constructors-are-static-inherent-methods-c-ctor"><h2>Constructors are static, inherent methods (C-CTOR)</h2></a>
<p>In Rust, &quot;constructors&quot; are just a convention. There are a variety of
conventions around constructor naming, and the distinctions are often
subtle.</p>
<p>A constructor in its most basic form is a <code>new</code> method with no arguments.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;T&gt; Example&lt;T&gt; {
    pub fn new() -&gt; Example&lt;T&gt; { /* ... */ }
}
#}</code></pre></pre>
<p>Constructors are static (no <code>self</code>) inherent methods for the type that they
construct. Combined with the practice of fully importing type names, this
convention leads to informative but concise construction:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use example::Example;

// Construct a new Example.
let ex = Example::new();
#}</code></pre></pre>
<p>The name <code>new</code> should generally be used for the primary method of instantiating
a type. Sometimes it takes no arguments, as in the examples above. Sometimes it
does take arguments, like <a href="https://doc.rust-lang.org/stable/std/boxed/struct.Box.html#method.new"><code>Box::new</code></a> which is passed the value to place in the
<code>Box</code>.</p>
<p>Some types' constructors, most notably I/O resource types, use distinct naming
conventions for their constructors, as in <a href="https://doc.rust-lang.org/stable/std/fs/struct.File.html#method.open"><code>File::open</code></a>, <a href="https://docs.rs/memmap/0.5.2/memmap/struct.Mmap.html#method.open"><code>Mmap::open</code></a>,
<a href="https://doc.rust-lang.org/stable/std/net/struct.TcpStream.html#method.connect"><code>TcpStream::connect</code></a>, and <a href="https://doc.rust-lang.org/stable/std/net/struct.UdpSocket.html#method.bind"><code>UpdSocket::bind</code></a>. In these cases names are chosen
as appropriate for the domain.</p>
<p>Often there are multiple ways to construct a type. It's common in these cases
for secondary constructors to be be suffixed, <code>_with_foo</code>, as in
<a href="https://docs.rs/memmap/0.5.2/memmap/struct.Mmap.html#method.open_with_offset"><code>Mmap::open_with_offset</code></a>. If your type has a multiplicity of construction
options though, consider the builder pattern (<a href="type-safety.html#c-builder">C-BUILDER</a>) instead.</p>
<p>Some constructors are &quot;conversion constructors&quot;, methods that create a new type
from an existing value of a different type. These typically have names begining
with <code>from_</code> as in <a href="https://doc.rust-lang.org/std/io/struct.Error.html#method.from_raw_os_error"><code>std::io::Error::from_raw_os_error</code></a>. Note also though the
<code>From</code> trait (<a href="interoperability.html#c-conv-traits">C-CONV-TRAITS</a>), which is quite similar. There are three
distinctions between a <code>from_</code>-prefixed conversion constructor and a <code>From&lt;T&gt;</code>
impl.</p>
<ul>
<li>A <code>from_</code> constructor can be unsafe; a <code>From</code> impl cannot. One example of this
is <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.from_raw"><code>Box::from_raw</code></a>.</li>
<li>A <code>from_</code> constructor can accept additional arguments to disambiguate the
meaning of the source data, as in <a href="https://doc.rust-lang.org/std/primitive.u64.html#method.from_str_radix"><code>u64::from_str_radix</code></a>.</li>
<li>A <code>From</code> impl is only appropriate when the source data type is sufficient to
determine the encoding of the output data type. When the input is just a bag
of bits like in <a href="https://doc.rust-lang.org/std/primitive.u64.html#method.from_be"><code>u64::from_be</code></a> or <a href="https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf8"><code>String::from_utf8</code></a>, the conversion
constructor name is able to identify their meaning.</li>
</ul>
<p>Note that it is common and expected for types to implement both <code>Default</code> and a
<code>new</code> constructor. For types that have both, they should have the same behavior.
Either one may be implemented in terms of the other.</p>
<a class="header" href="predictability.html#examples-from-the-standard-library-1" id="examples-from-the-standard-library-1"><h3>Examples from the standard library</h3></a>
<ul>
<li><a href="https://doc.rust-lang.org/std/io/struct.Error.html#method.new"><code>std::io::Error::new</code></a> is the commonly used constructor for an IO error.</li>
<li><a href="https://doc.rust-lang.org/std/io/struct.Error.html#method.from_raw_os_error"><code>std::io::Error::from_raw_os_error</code></a> is a conversion constructor
based on an error code received from the operating system.</li>
<li><a href="https://doc.rust-lang.org/stable/std/boxed/struct.Box.html#method.new"><code>Box::new</code></a> creates a new container type, taking a single argument.</li>
<li><a href="https://doc.rust-lang.org/stable/std/fs/struct.File.html#method.open"><code>File::open</code></a> opens a file resource.</li>
<li><a href="https://docs.rs/memmap/0.5.2/memmap/struct.Mmap.html#method.open_with_offset"><code>Mmap::open_with_offset</code></a> opens a memory-mapped file, with additional options.</li>
</ul>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="documentation.html" class="mobile-nav-chapters previous" title="Previous chapter">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="flexibility.html" class="mobile-nav-chapters next" title="Next chapter">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="documentation.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="flexibility.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
